{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\n\n/**\n * Custom hook for throttled scroll event handling\n * Prevents memory leaks and performance issues with scroll listeners\n * \n * @param {Function} callback - Function to call on scroll\n * @param {number} delay - Throttle delay in milliseconds (default: 16ms for 60fps)\n * @param {Array} deps - Dependencies array for the callback\n */\nexport const useThrottledScroll = (callback, delay = 16, deps = []) => {\n  _s();\n  const savedCallback = useRef(callback);\n  const throttleTimeoutRef = useRef(null);\n  const lastExecutedRef = useRef(0);\n\n  // Remember the latest callback\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback, ...deps]);\n\n  // Throttled scroll handler\n  const throttledScrollHandler = useCallback(() => {\n    const now = Date.now();\n    const timeSinceLastExecution = now - lastExecutedRef.current;\n    if (timeSinceLastExecution >= delay) {\n      // Execute immediately if enough time has passed\n      savedCallback.current();\n      lastExecutedRef.current = now;\n    } else {\n      // Schedule execution for the remaining time\n      if (throttleTimeoutRef.current) {\n        clearTimeout(throttleTimeoutRef.current);\n      }\n      throttleTimeoutRef.current = setTimeout(() => {\n        savedCallback.current();\n        lastExecutedRef.current = Date.now();\n        throttleTimeoutRef.current = null;\n      }, delay - timeSinceLastExecution);\n    }\n  }, [delay]);\n  useEffect(() => {\n    // Add scroll listener\n    window.addEventListener('scroll', throttledScrollHandler, {\n      passive: true\n    });\n\n    // Cleanup function\n    return () => {\n      window.removeEventListener('scroll', throttledScrollHandler);\n      if (throttleTimeoutRef.current) {\n        clearTimeout(throttleTimeoutRef.current);\n      }\n    };\n  }, [throttledScrollHandler]);\n};\n_s(useThrottledScroll, \"uVHVvye0w2D3V8v7wTEufqRMPng=\");","map":{"version":3,"names":["useEffect","useRef","useCallback","useThrottledScroll","callback","delay","deps","_s","savedCallback","throttleTimeoutRef","lastExecutedRef","current","throttledScrollHandler","now","Date","timeSinceLastExecution","clearTimeout","setTimeout","window","addEventListener","passive","removeEventListener"],"sources":["/Users/karthi/Desktop/Myna Kitchen/myna/src/hooks/useThrottledScroll.js"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\n\n/**\n * Custom hook for throttled scroll event handling\n * Prevents memory leaks and performance issues with scroll listeners\n * \n * @param {Function} callback - Function to call on scroll\n * @param {number} delay - Throttle delay in milliseconds (default: 16ms for 60fps)\n * @param {Array} deps - Dependencies array for the callback\n */\nexport const useThrottledScroll = (callback, delay = 16, deps = []) => {\n  const savedCallback = useRef(callback);\n  const throttleTimeoutRef = useRef(null);\n  const lastExecutedRef = useRef(0);\n\n  // Remember the latest callback\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback, ...deps]);\n\n  // Throttled scroll handler\n  const throttledScrollHandler = useCallback(() => {\n    const now = Date.now();\n    const timeSinceLastExecution = now - lastExecutedRef.current;\n\n    if (timeSinceLastExecution >= delay) {\n      // Execute immediately if enough time has passed\n      savedCallback.current();\n      lastExecutedRef.current = now;\n    } else {\n      // Schedule execution for the remaining time\n      if (throttleTimeoutRef.current) {\n        clearTimeout(throttleTimeoutRef.current);\n      }\n      \n      throttleTimeoutRef.current = setTimeout(() => {\n        savedCallback.current();\n        lastExecutedRef.current = Date.now();\n        throttleTimeoutRef.current = null;\n      }, delay - timeSinceLastExecution);\n    }\n  }, [delay]);\n\n  useEffect(() => {\n    // Add scroll listener\n    window.addEventListener('scroll', throttledScrollHandler, { passive: true });\n\n    // Cleanup function\n    return () => {\n      window.removeEventListener('scroll', throttledScrollHandler);\n      if (throttleTimeoutRef.current) {\n        clearTimeout(throttleTimeoutRef.current);\n      }\n    };\n  }, [throttledScrollHandler]);\n}; "],"mappings":";AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAGA,CAACC,QAAQ,EAAEC,KAAK,GAAG,EAAE,EAAEC,IAAI,GAAG,EAAE,KAAK;EAAAC,EAAA;EACrE,MAAMC,aAAa,GAAGP,MAAM,CAACG,QAAQ,CAAC;EACtC,MAAMK,kBAAkB,GAAGR,MAAM,CAAC,IAAI,CAAC;EACvC,MAAMS,eAAe,GAAGT,MAAM,CAAC,CAAC,CAAC;;EAEjC;EACAD,SAAS,CAAC,MAAM;IACdQ,aAAa,CAACG,OAAO,GAAGP,QAAQ;EAClC,CAAC,EAAE,CAACA,QAAQ,EAAE,GAAGE,IAAI,CAAC,CAAC;;EAEvB;EACA,MAAMM,sBAAsB,GAAGV,WAAW,CAAC,MAAM;IAC/C,MAAMW,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;IACtB,MAAME,sBAAsB,GAAGF,GAAG,GAAGH,eAAe,CAACC,OAAO;IAE5D,IAAII,sBAAsB,IAAIV,KAAK,EAAE;MACnC;MACAG,aAAa,CAACG,OAAO,CAAC,CAAC;MACvBD,eAAe,CAACC,OAAO,GAAGE,GAAG;IAC/B,CAAC,MAAM;MACL;MACA,IAAIJ,kBAAkB,CAACE,OAAO,EAAE;QAC9BK,YAAY,CAACP,kBAAkB,CAACE,OAAO,CAAC;MAC1C;MAEAF,kBAAkB,CAACE,OAAO,GAAGM,UAAU,CAAC,MAAM;QAC5CT,aAAa,CAACG,OAAO,CAAC,CAAC;QACvBD,eAAe,CAACC,OAAO,GAAGG,IAAI,CAACD,GAAG,CAAC,CAAC;QACpCJ,kBAAkB,CAACE,OAAO,GAAG,IAAI;MACnC,CAAC,EAAEN,KAAK,GAAGU,sBAAsB,CAAC;IACpC;EACF,CAAC,EAAE,CAACV,KAAK,CAAC,CAAC;EAEXL,SAAS,CAAC,MAAM;IACd;IACAkB,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAEP,sBAAsB,EAAE;MAAEQ,OAAO,EAAE;IAAK,CAAC,CAAC;;IAE5E;IACA,OAAO,MAAM;MACXF,MAAM,CAACG,mBAAmB,CAAC,QAAQ,EAAET,sBAAsB,CAAC;MAC5D,IAAIH,kBAAkB,CAACE,OAAO,EAAE;QAC9BK,YAAY,CAACP,kBAAkB,CAACE,OAAO,CAAC;MAC1C;IACF,CAAC;EACH,CAAC,EAAE,CAACC,sBAAsB,CAAC,CAAC;AAC9B,CAAC;AAACL,EAAA,CA7CWJ,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}