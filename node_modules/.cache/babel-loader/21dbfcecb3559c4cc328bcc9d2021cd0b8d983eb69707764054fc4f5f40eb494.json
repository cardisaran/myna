{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\n\n/**\n * Optimized custom hook for throttled scroll event handling\n * Prevents memory leaks and performance issues with scroll listeners\n * Uses requestAnimationFrame for optimal performance\n * \n * @param {Function} callback - Function to call on scroll\n * @param {number} delay - Throttle delay in milliseconds (default: 33ms for 30fps)\n * @param {Array} deps - Dependencies array for the callback\n */\nexport const useThrottledScroll = (callback, delay = 33, deps = []) => {\n  _s();\n  const savedCallback = useRef(callback);\n  const rafRef = useRef(null);\n  const lastExecutedRef = useRef(0);\n  const isThrottled = useRef(false);\n\n  // Remember the latest callback\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback, ...deps]);\n\n  // Optimized scroll handler using requestAnimationFrame\n  const throttledScrollHandler = useCallback(() => {\n    if (isThrottled.current) return;\n    const now = performance.now();\n    const timeSinceLastExecution = now - lastExecutedRef.current;\n    if (timeSinceLastExecution >= delay) {\n      // Execute immediately if enough time has passed\n      isThrottled.current = true;\n      rafRef.current = requestAnimationFrame(() => {\n        savedCallback.current();\n        lastExecutedRef.current = performance.now();\n        isThrottled.current = false;\n      });\n    } else {\n      // Schedule execution using requestAnimationFrame for the remaining time\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      const remainingTime = delay - timeSinceLastExecution;\n      setTimeout(() => {\n        if (!isThrottled.current) {\n          isThrottled.current = true;\n          rafRef.current = requestAnimationFrame(() => {\n            savedCallback.current();\n            lastExecutedRef.current = performance.now();\n            isThrottled.current = false;\n          });\n        }\n      }, remainingTime);\n    }\n  }, [delay]);\n  useEffect(() => {\n    // Add scroll listener with passive for better performance\n    window.addEventListener('scroll', throttledScrollHandler, {\n      passive: true,\n      capture: false\n    });\n\n    // Cleanup function\n    return () => {\n      window.removeEventListener('scroll', throttledScrollHandler);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      isThrottled.current = false;\n    };\n  }, [throttledScrollHandler]);\n};\n_s(useThrottledScroll, \"81FK24UmiWVssemCGp9ixrp/j5U=\");","map":{"version":3,"names":["useEffect","useRef","useCallback","useThrottledScroll","callback","delay","deps","_s","savedCallback","rafRef","lastExecutedRef","isThrottled","current","throttledScrollHandler","now","performance","timeSinceLastExecution","requestAnimationFrame","cancelAnimationFrame","remainingTime","setTimeout","window","addEventListener","passive","capture","removeEventListener"],"sources":["/Users/karthi/Desktop/Myna Kitchen/myna/src/hooks/useThrottledScroll.js"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\n\n/**\n * Optimized custom hook for throttled scroll event handling\n * Prevents memory leaks and performance issues with scroll listeners\n * Uses requestAnimationFrame for optimal performance\n * \n * @param {Function} callback - Function to call on scroll\n * @param {number} delay - Throttle delay in milliseconds (default: 33ms for 30fps)\n * @param {Array} deps - Dependencies array for the callback\n */\nexport const useThrottledScroll = (callback, delay = 33, deps = []) => {\n  const savedCallback = useRef(callback);\n  const rafRef = useRef(null);\n  const lastExecutedRef = useRef(0);\n  const isThrottled = useRef(false);\n\n  // Remember the latest callback\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback, ...deps]);\n\n  // Optimized scroll handler using requestAnimationFrame\n  const throttledScrollHandler = useCallback(() => {\n    if (isThrottled.current) return;\n    \n    const now = performance.now();\n    const timeSinceLastExecution = now - lastExecutedRef.current;\n\n    if (timeSinceLastExecution >= delay) {\n      // Execute immediately if enough time has passed\n      isThrottled.current = true;\n      \n      rafRef.current = requestAnimationFrame(() => {\n        savedCallback.current();\n        lastExecutedRef.current = performance.now();\n        isThrottled.current = false;\n      });\n    } else {\n      // Schedule execution using requestAnimationFrame for the remaining time\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      \n      const remainingTime = delay - timeSinceLastExecution;\n      \n      setTimeout(() => {\n        if (!isThrottled.current) {\n          isThrottled.current = true;\n          rafRef.current = requestAnimationFrame(() => {\n            savedCallback.current();\n            lastExecutedRef.current = performance.now();\n            isThrottled.current = false;\n          });\n        }\n      }, remainingTime);\n    }\n  }, [delay]);\n\n  useEffect(() => {\n    // Add scroll listener with passive for better performance\n    window.addEventListener('scroll', throttledScrollHandler, { \n      passive: true,\n      capture: false \n    });\n\n    // Cleanup function\n    return () => {\n      window.removeEventListener('scroll', throttledScrollHandler);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      isThrottled.current = false;\n    };\n  }, [throttledScrollHandler]);\n}; "],"mappings":";AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAGA,CAACC,QAAQ,EAAEC,KAAK,GAAG,EAAE,EAAEC,IAAI,GAAG,EAAE,KAAK;EAAAC,EAAA;EACrE,MAAMC,aAAa,GAAGP,MAAM,CAACG,QAAQ,CAAC;EACtC,MAAMK,MAAM,GAAGR,MAAM,CAAC,IAAI,CAAC;EAC3B,MAAMS,eAAe,GAAGT,MAAM,CAAC,CAAC,CAAC;EACjC,MAAMU,WAAW,GAAGV,MAAM,CAAC,KAAK,CAAC;;EAEjC;EACAD,SAAS,CAAC,MAAM;IACdQ,aAAa,CAACI,OAAO,GAAGR,QAAQ;EAClC,CAAC,EAAE,CAACA,QAAQ,EAAE,GAAGE,IAAI,CAAC,CAAC;;EAEvB;EACA,MAAMO,sBAAsB,GAAGX,WAAW,CAAC,MAAM;IAC/C,IAAIS,WAAW,CAACC,OAAO,EAAE;IAEzB,MAAME,GAAG,GAAGC,WAAW,CAACD,GAAG,CAAC,CAAC;IAC7B,MAAME,sBAAsB,GAAGF,GAAG,GAAGJ,eAAe,CAACE,OAAO;IAE5D,IAAII,sBAAsB,IAAIX,KAAK,EAAE;MACnC;MACAM,WAAW,CAACC,OAAO,GAAG,IAAI;MAE1BH,MAAM,CAACG,OAAO,GAAGK,qBAAqB,CAAC,MAAM;QAC3CT,aAAa,CAACI,OAAO,CAAC,CAAC;QACvBF,eAAe,CAACE,OAAO,GAAGG,WAAW,CAACD,GAAG,CAAC,CAAC;QAC3CH,WAAW,CAACC,OAAO,GAAG,KAAK;MAC7B,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACA,IAAIH,MAAM,CAACG,OAAO,EAAE;QAClBM,oBAAoB,CAACT,MAAM,CAACG,OAAO,CAAC;MACtC;MAEA,MAAMO,aAAa,GAAGd,KAAK,GAAGW,sBAAsB;MAEpDI,UAAU,CAAC,MAAM;QACf,IAAI,CAACT,WAAW,CAACC,OAAO,EAAE;UACxBD,WAAW,CAACC,OAAO,GAAG,IAAI;UAC1BH,MAAM,CAACG,OAAO,GAAGK,qBAAqB,CAAC,MAAM;YAC3CT,aAAa,CAACI,OAAO,CAAC,CAAC;YACvBF,eAAe,CAACE,OAAO,GAAGG,WAAW,CAACD,GAAG,CAAC,CAAC;YAC3CH,WAAW,CAACC,OAAO,GAAG,KAAK;UAC7B,CAAC,CAAC;QACJ;MACF,CAAC,EAAEO,aAAa,CAAC;IACnB;EACF,CAAC,EAAE,CAACd,KAAK,CAAC,CAAC;EAEXL,SAAS,CAAC,MAAM;IACd;IACAqB,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAET,sBAAsB,EAAE;MACxDU,OAAO,EAAE,IAAI;MACbC,OAAO,EAAE;IACX,CAAC,CAAC;;IAEF;IACA,OAAO,MAAM;MACXH,MAAM,CAACI,mBAAmB,CAAC,QAAQ,EAAEZ,sBAAsB,CAAC;MAC5D,IAAIJ,MAAM,CAACG,OAAO,EAAE;QAClBM,oBAAoB,CAACT,MAAM,CAACG,OAAO,CAAC;MACtC;MACAD,WAAW,CAACC,OAAO,GAAG,KAAK;IAC7B,CAAC;EACH,CAAC,EAAE,CAACC,sBAAsB,CAAC,CAAC;AAC9B,CAAC;AAACN,EAAA,CAhEWJ,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}